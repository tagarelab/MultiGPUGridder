<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Multi-GPU Gridding: Documentation/MainPage.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Multi-GPU Gridding
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Documentation/MainPage.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_main_page_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;\mainpage Multi-GPU Gridding Index Page</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;\section Introduction</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;For many applications, it is needed to perform many iterations of forward and back projection in the Fourier domain.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Here, we provide a class for fast forward and back projection which utilizes multiple NVIDIA GPUs, CUDA, and C++ along with a </div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;wrapper for calling all the functions from within Matlab or from within Python.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;\section Dependencies </div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;| Library      | Version   | Usage                                                                                       |</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;|--------------|-----------|---------------------------------------------------------------------------------------------|</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;| **CUDA**         | &gt;= 10.0   | Used for calling the GPU functions and processing data on the GPU.|</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;| **NVCC**         | &gt;= 10.0   | NVIDIA CUDA compiler for compiling the GPU code. This should be included with the CUDA download.|</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;| **C++ Compiler** | &gt;= C++11  | A C++ compiler is needed for compiling the C++ code.|</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;| **Nvidia GPU**    |  &gt;=3.0  Compute capability       | Between 1 and 12 NVIDIA GPUs are required.|</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;| **Matlab**       | &gt;= R2018a | Optional: If compiling the MATLAB wrappers for calling the class.|</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;| **Python**       | &gt;= 3.0    | Optional: If compiling the Python wrappers for calling the class.|</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;\section install_sec Installation</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;### Step 1: Clone or download the GitHub repository to your computer.</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;### Step 2: Open the CMake GUI with the source code path to be the &quot;src&quot; folder and the binaries path to be a new folder name &quot;bin&quot;.</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;### Step 3: Within CMake, click on Configure</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;### Step 4: Check or uncheck the optional settings (such as BUILD_TESTS and WITH_MATLAB).</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;### Step 5: Click configure again and then click on Generate.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;### Step 6 (Windows): Click on Open Project which should open Visual Studio. Then right click on ALL_BUILD and click on build. Decide between Debug or Release (see the drop down on the top center within Visual Studio).</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;### Step 6 (Linux): Close CMake and open a terminal within the bin folder (which was created by CMake). Within the terminal type &quot;make&quot; which will then compile the code.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;### Step 7: Optionally, run the units tests within Matlab and / or Python to check everything is functioning correctly.</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;\section Video Tutorial</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;[Please see the video tutorial for further details and examples of the software](https://youtu.be/gO2kiizHO4g)</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;\section Example</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;Here is a simple example on running the Matlab wrapper:</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    % Add the required Matlab file paths</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    mfilepath=fileparts(which(&#39;MultiGPUGridder_Matlab_Class.m&#39;));</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    addpath(genpath(fullfile(mfilepath)));</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    % Parameters for creating the volume and coordinate axes</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    VolumeSize = 128;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    interpFactor = 2;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    n1_axes = 100;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    n2_axes = 100;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    % Create the volume</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    load mri;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    MRI_volume = squeeze(D);</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    MRI_volume = imresize3(MRI_volume,[VolumeSize, VolumeSize, VolumeSize]);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    % Define the projection directions</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    coordAxes = create_uniform_axes(n1_axes,n2_axes,0,10);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    % Create the gridder object</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    gridder = MultiGPUGridder_Matlab_Class(VolumeSize, n1_axes * n2_axes, interpFactor);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    % Set the volume</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    gridder.setVolume(MRI_volume);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    % Run the forward projection</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    images = gridder.forwardProject(coordAxes);    </div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    easyMontage(images, 1)</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    % Run the back projection</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    gridder.resetVolume();</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    gridder.backProject(gridder.Images, coordAxes)</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    vol=gridder.getVol();</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    easyMontage(vol, 2)</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    % Reconstruct the volume</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    reconstructVol = gridder.reconstructVol();</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    easyMontage(reconstructVol, 3)</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;![Matlab_Example](../../Documentation/Images/Matlab_Example.png)</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;\section matlab_unit_tests Matlab - Unit Tests</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;The package also provides units tests to run within Matlab. The tests verify that each CUDA kernel returns the expected output. Additionally, there are unit tests for the forward and back projection kernels which test the output from each GPU, a combintation of GPUs, and varied parameters such as the volume size, number of projection directions, and the number of CUDA streams. In order to run the unit tests, go to the /src/unit_tests folder. Then within Matlab, run the Run_Unit_Tests.m script. </div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;For changing the testing parameters (such as if your computer has a different number of GPUs), modify the GPU_Device parameter at the top of FilterTest.m, ForwardProjectTests.m, and BackProjectTests.m. Also feel free to modify the other testing parameters as well.</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;\section cuda CUDA - Asynchronous memory transfers</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;For large datasets, there is significant copying of data to/from the GPUs. CUDA allows for overlapping of memory transfers and kernel executation (see [NVIDIA documentation for further information](https://devblogs.nvidia.com/how-overlap-data-transfers-cuda-cc/). This greatly lowers the computation time for large datasets. CUDA streams allow us to perform this.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;![CUDA_Streaming_Overview](../../Documentation/Images/CUDA_Streaming_Overview.png)</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;For example, in the gpuGridder::ForwardProject function, we perform asynchronous (async) memory transfers from the host (i.e.the CPU) to the device (i.e.the GPU). The following simplified code illustrates this</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    cudaMemcpyAsync(</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        d_CoordAxes-&gt;GetPointer(),</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        h_CoordAxes-&gt;GetPointer(),</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        bytes,</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        cudaMemcpyHostToDevice,</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        CUDA_Stream);</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;A **bytes** length of memory from the host memory pointer **h_CoordAxes-&gt;GetPointer()** to the device memory pointer **d_CoordAxes-&gt;GetPointer()** is copied using the **CUDA_Stream**. A corresponding call can be used to copy device memory back to the host.</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        </div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;\section cuda CUDA - Asynchronous kernel calls</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;Similarly to the memory transfers, we also use CUDA streams for calling the GPU kernels. This lets us create a queue of work for each GPU to execute simultaneously. The included filters also use CUDA streams such as the FFTShift2DFilter as shown below</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    // Run a FFTShift on each 2D slice</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    FFTShift2DFilter&lt;cufftComplex&gt; *FFTShiftFilter = new FFTShift2DFilter&lt;cufftComplex&gt;();</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    FFTShiftFilter-&gt;SetInput(Images);</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    FFTShiftFilter-&gt;SetImageSize(ImageSize);</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    FFTShiftFilter-&gt;SetNumberOfSlices(nSlices);</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    FFTShiftFilter-&gt;Update(&amp;stream);</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;The CUDA stream is assigned by simply passing the reference to the stream (&amp;stream) to the FFTShift2DFilter::Update function. The other filters work in the same way.</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;\section matlab_wrapper Matlab Wrapper - Memory Persistance</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;First, we need to have the host memory persistant when going back to Matlab in order to only need to allocate both the host and device memory once.</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;We achieved this though the mexFunctionWrapper.h. This header file and associated functions are used for keeping both the host (i.e. CPU) and the device (i.e. GPU) memory persisant when going back and forth to Matlab. Essentially, when the MultiGPUGridder object is created, the corresponding memory pointer is converted to a **real uint64 scalar** and returned to Matlab. This scalar is remembered within the Matlab class (by the **objectHandle** member). Then, after the object is created, when a mex function is called the objectHandle (i.e.the **real uint64 scalar**) is passed from Matlab to the C++ code and then recasted back into the MultiGPUGridder C++ object. This allows us to maintain the memory between Matlab mex function calls.</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;Therefore, each of the mex functions has this line of code:</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    MultiGPUGridder *MultiGPUGridderObj = convertMat2Ptr&lt;MultiGPUGridder&gt;(prhs[0]);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;The prhs[0] refers to the first variable sent from Matlab (see the Matlab documentation on the prhs). The prhs stands for right hand side (i.e.the inputs) while the plhs stands for the left hand side (i.e.the outputs), similarly to Matlab functions.</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;The</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    convertMat2Ptr&lt;&gt;()</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;function takes the **real uint64 scalar** (which was passed from the Matlab class to the mex function) and casts the pointer to the MultiGPUGridder class to get the object back. The convertPtr2Mat&lt;&gt;() function does that opposite (convert the memory pointer to a real uint64 scalar) to return back to Matlab.</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;\section matlab_in_place Matlab Wrapper - In-place computation</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;In order to avoid unnecessary copying to and from Matlab as well as to avoid unneeded memory allocation, we perform the calculations in place. The steps were then</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;1. Matlab allocated the arrays (within Matlab) the standard way. For example, X = zeros(64, 64, 64).</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;2. Using the mexSetVariables wrapper, the mex function mxGetData() was used to get the memory pointer to the Matlab allocated array.</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;3. The pointer was then passed to the MultiGPUGridder object.</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;4. The memory was directly read using the pointer any output was copied to the corresponding memory location.</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;5. After returning to Matlab, the associated changes to the array are displayed within Matlab (without the need to copy to/from Matlab).</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;For a specific example, when setting the array which corresponds to the volumethe mexSetVariables was called with the following inputs:</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;(1) a string &#39;SetVolume&#39; to specify which array we&#39;re passing, (2) objectHandle (i.e.the real uint64 scalar which corresponds to the MultiGPUGridder object created in mexCreateGridder), (3) the volume, and (4) a vector with the volume dimenstions. Within mexSetVariables, the function call was the following:</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    // Pointer to the volume array and the dimensions of the array</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    MultiGPUGridderObj-&gt;SetVolume((float *)mxGetData(prhs[2]), (int *)mxGetData(prhs[3]));</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;Then within the AbstractGridder (which is the parent class of the MultiGPUGridder class) the SetVolume function is the following</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    void AbstractGridder::SetVolume(float *Volume, int *ArraySize)</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    {</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        // First save the given pointer</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        if (this-&gt;VolumeInitialized == false)</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        {</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            this-&gt;h_Volume = new HostMemory&lt;float&gt;(3, ArraySize);</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            this-&gt;h_Volume-&gt;CopyPointer(Volume);</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            this-&gt;h_Volume-&gt;PinArray();</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            this-&gt;VolumeInitialized = true;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        }</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        else</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        {</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            // Just copy the pointer</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            this-&gt;h_Volume-&gt;CopyPointer(Volume);</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    }</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;Here, we create a new HostMemory object and copy the pointer of the Matlab allocated array. We lastly pin the memory to allow for</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;asynchronous memory transfer to and from the GPUs. Please see the [NVIDIA documentation for further information](https://devblogs.nvidia.com/how-overlap-data-transfers-cuda-cc/).</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;\section matlab_mex Matlab Wrapper - Mex Functions</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;| Mex Wrapper File Name        | Purpose                                                                            |</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;|------------------------------|------------------------------------------------------------------------------------|</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;| mexCreateGridder             | Creates the MultiGPUGridder object                                                 |</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;| mexDeleteGridder             | Deletes and deallocates the MultiGPUGridder object                                 |</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;| mexSetVariables              | Passes the pointers from the Matlab allocated arrays to the MultiGPUGridder object |</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;| mexMultiGPUForwardProject    | Calls the forward projection function                                              |</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;| mexMultiGPUBackProject       | Call the back projection function                                                  |</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;| mexMultiGPUGetVolume         | Runs an inverse FFT to get the volume                                              |</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;| mexMultiGPUReconstructVolume | Normalizes by the plane density and runs an inverse FFT to get the volume          |</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;The mexCreateGridder creates an instance of the MultiGPUGridder class. The MultiGPUGridder class then creates an instance of the gpuGridder class with one gpuGridder object per GPU. Then in the mexMultiGPUForwardProject function for example, the MultiGPUGridder object simply iterates over the gpuGridder objects and calls the gpuGridder::ForwardProject function. See the figure below for a graphical representation of this.</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;![Multi_GPU_Gridder_Overview](../../Documentation/Images/Multi_GPU_Gridder_Overview.png)</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 2 2020 10:18:08 for Multi-GPU Gridding by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
